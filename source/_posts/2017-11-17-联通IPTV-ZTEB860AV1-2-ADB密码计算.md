---
title: 联通IPTV ZTEB860AV1.2 ADB密码计算
date: 2017-11-17 09:37:31
tags: [iptv,adb,破解]
---

## 需求
办理的联通宽带，增送iptv，可惜一直没有电视。丈母娘家的小旅馆歇业了，趁个周末就去搬了台电视回来。当时正值S赛期间，iptv盒子不能装直播软件看比赛，确实不爽。
## 方案
上网研究了半天，发现这款盒子可以通过打开远程ADB的方式远程安装app。不过开启远程ADB却需要密码。
## 原由
论坛上有个“三无”APP，安装后输入随机数和mac地址可以计算出密码。出于对“三无”APP缺失安全感，也是因为好奇，决定逆向看看这个密码是怎么算出来的。
## 开动吧
apk改后缀名zip，提取so扔进ida。
```c
int __fastcall getHashcode(char *a1, char *a2)
{
  char *v2; // r6@1
  char *v3; // r5@1
  int v4; // r2@1
  int v5; // r3@1
  int v6; // r0@1
  int result; // r0@1
  char s; // [sp+1Ch] [bp-114h]@1
  char v9; // [sp+9Ch] [bp-94h]@1
  int v10; // [sp+11Ch] [bp-14h]@1

  v2 = a1;
  v3 = a2;
  v10 = _stack_chk_guard;
  printf("rand =%s\n", a1);
  printf("mac =%s\n", v3);
  memset(&s, 0, 0x80u);
  memset(&v9, 0, 0x80u);
  _sprintf_chk(&s, 0, 128, "%s%s%s%s%s", "open_ADB", v2, "@", v3, "ZTE_ENCRYPT");
  printf("MD5 %s\n", &s);
  md5_string(&s, (int)&v9, v4, v5);
  printf("chashnum %s\n", &v9);
  v6 = hashcode(&v9);
  printf("%d\n", v6);
  result = hashcode(&v9);
  if ( v10 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}

int __fastcall hashcode(const char *a1)
{
  const char *v1; // r6@1
  int v2; // r0@1
  int v3; // r2@2
  signed int v4; // r12@2
  int v5; // r1@3
  int result; // r0@6
  char s[1024]; // [sp+4h] [bp-414h]@1
  int v8; // [sp+404h] [bp-14h]@1

  v1 = a1;
  v8 = _stack_chk_guard;
  memset(s, 0, 0x400u);
  _strcpy_chk(s, v1, 1024);
  v2 = _strlen_chk(s, 1024);
  if ( v2 )
  {
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = (unsigned __int8)s[v3++];
      v4 = v5 + 31 * v4;
    }
    while ( v3 != v2 );
  }
  else
  {
    v4 = 0;
  }
  result = (v4 ^ (v4 >> 31)) - (v4 >> 31);
  if ( v8 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
```

getHashcode函数参数，a1是随机数，a2是mac地址。
```python
text = "open_ADB", v2, "@", v3, "ZTE_ENCRYPT"
hash =md5(text)
pass = hashcode(hash)
```
hashcode就是计算一个校验值。

## 后续
等有时间了，把hashcode的计算改成python仍在web上，做个在线计算。